use num::rational::Ratio;

use ast::*;
use value::Value;
use op::OpCode;
use lexer::Token;

grammar;

extern {
    enum Token {
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "-" => Token::Minus,
        "=" => Token::Op(OpCode::Equals),
        "+" => Token::Op(OpCode::Add),
        "*" => Token::Op(OpCode::Mul),
        "/" => Token::Op(OpCode::Div),
        "^" => Token::Op(OpCode::Pow),
        "." => Token::Dot,
        ":=" => Token::Assign,
        "," => Token::Comma,
        ":" => Token::Colon,
        "|" => Token::Alternate,
        "none" => Token::None,
        boolean => Token::Bool(<bool>),
        num => Token::Num(<Ratio<i32>>),
        string => Token::Str(<String>),
        identifier => Token::Id(<String>),
    }
}

// comma separated list of values with optional trailing comma
comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// expression tier, used for operator precedence
tier<Op, NextTier>: Expr = {
    <lhs: tier<Op, NextTier>> <op: Op> <rhs: NextTier> => Expr::Op(
        FunCall::new_with_args(op, vec![], vec![lhs, rhs])
    ),
    NextTier
};

// a pair separated by a colon
colon_pair<T, U>: (T, U) = <T> ":" <U> => (<>, <>);

alt_pair: (Expr, Option<Expr>) = {
    <a: tier_1_op> => (a, None),
    <a: tier_1_op> ":" <b: tier_1_op> => (a, Some(b)),
};

pub expr: Expr = {
    tier_1_op => <>,
    <lhs: identifier> ":=" <e:expr> => Expr::Assign(lhs, Box::new(e)),
    <lhs: alt_pair> "|" <rhs: alt_pair> <list: ("|" <alt_pair>)*> => {
        // alternation that builds a distribution
        use std::collections::BTreeMap;
        let mut distr = BTreeMap::new();

        let one_expr = Expr::Val(1.0f32.into());

        // add left and right sides
        distr.insert(lhs.0, lhs.1.unwrap_or(one_expr.clone()));
        distr.insert(rhs.0, rhs.1.unwrap_or(one_expr.clone()));

        // add the rest
        for (exp, opt_weight) in list {
            distr.insert(exp, opt_weight.unwrap_or(one_expr.clone()));
        }

        // return distribution
        Expr::Distribution(distr)
    },
};

// precedence levels
tier_1_op: Expr = tier<operator_1, tier_2_op>;
tier_2_op: Expr = tier<operator_2, tier_3_op>;
tier_3_op: Expr = tier<operator_3, tier_4_op>;
tier_4_op: Expr = tier<operator_4, tier_5_op>;

tier_5_op: Expr = {
    "-" <e: value> => Expr::Op(
        FunCall::new_with_args(OpCode::Neg, vec![], vec![e])
    ),
    value => <>,
};

value: Expr = {
    term => Expr::Val(<>),
    identifier => Expr::Id(<>),
    "[" <comma<expr>> "]" => Expr::List(<>),
    "{" <comma<expr>> "}" => Expr::Set(<>.into_iter().collect()),
    <id: identifier> "(" <args: comma<expr>> ")" => Expr::Op(
        FunCall::new_with_args(OpCode::Id(id), vec![], args)
    ),
    "(" <expr> ")" => <>,
};

term: Value = {
    "none" => Value::None,
    boolean => Value::Bool(<>),
    num => Value::Num(<>),
    string => Value::new_string(&<>),
};

operator_1: OpCode = {
    "=" => OpCode::Equals,
};

operator_2: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

operator_3: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

operator_4: OpCode = {
    "^" => OpCode::Pow,
};
