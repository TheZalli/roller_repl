use std::str::FromStr;

use ast::*;
use value::Value;
use op::OpCode;

grammar;

// comma separated list of values with optional trailing comma
comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// expression tier, used for operator precedence
tier<Op, NextTier>: Expr = {
    <lhs: tier<Op, NextTier>> <op: Op> <rhs: NextTier> => Expr::Op(
        FunCall::new_with_args(op, vec![], vec![lhs, rhs])
    ),
    NextTier
};

// a pair separated by a colon
colon_pair<T, U>: (T, U) = <T> ":" <U> => (<>, <>);

alt_pair: (Expr, Option<Expr>) = {
    <a:infix_op_1> => (a, None),
    <a:infix_op_1> ":" <b:infix_op_1> => (a, Some(b)),
};

pub expr: Expr = {
    infix_op_1 => <>,
    <lhs: alt_pair> "|" <rhs: alt_pair> <list: ("|" <alt_pair>)*> => {
        // alternation that builds a distribution
        use std::collections::BTreeMap;
        let mut distr = BTreeMap::new();

        let one_expr = Expr::Val(1.0f64.into());

        // add left and right sides
        distr.insert(lhs.0, lhs.1.unwrap_or(one_expr.clone()));
        distr.insert(rhs.0, rhs.1.unwrap_or(one_expr.clone()));

        // add the rest
        for (exp, opt_weight) in list {
            distr.insert(exp, opt_weight.unwrap_or(one_expr.clone()));
        }

        // return distribution
        Expr::Distribution(distr)
    },
};

// precedence levels
infix_op_1: Expr = tier<operator_1, infix_op_2>;
infix_op_2: Expr = tier<operator_2, infix_op_3>;
infix_op_3: Expr = tier<operator_3, infix_op_4>;
infix_op_4: Expr = tier<operator_4, value>;

value: Expr = {
    term => Expr::Val(<>),
    identifier => Expr::Id(<>),
    "List" "(" <comma<expr>> ")" => Expr::List(<>),
    "Set" "(" <comma<expr>> ")" => Expr::Set(<>.into_iter().collect()),
    <id: identifier> "(" <args: comma<expr>> ")" => Expr::Op(
        FunCall::new_with_args(OpCode::Id(id), vec![], args)
    ),
    "(" <expr> ")" => <>,
};

term: Value = {
    "none" => Value::None,
    "true" => Value::Bool(true),
    "false" => Value::Bool(false),
    num => <>.into(),
};

identifier: String = r"([\pL_][\pL\pN_]*)" => <>.to_owned();

int: u64 = {
    r"[0-9]+" => u64::from_str(<>).unwrap(),
};

float: f64 = {
    // the reason this looks so scary is that we don't want to match integer 
    // literals because that is an ambiguity and lalrpop match structure isn't 
    // working.
    // TODO fix
    r"[0-9]+(\.[0-9]+|(\.[0-9]+)?[Ee][-+]?[0-9]+)" =>
    f64::from_str(<>).unwrap(),
};

num: f64 = {
    <i:int> => i as f64,
    <f:float> => f,
};

operator_1: OpCode = {
    "=" => OpCode::Assign,
};

operator_2: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

operator_3: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

operator_4: OpCode = {
    "^" => OpCode::Exp,
};
