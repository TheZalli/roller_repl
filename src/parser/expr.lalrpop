use num::rational::Ratio;

use ast::*;
use value::{Value, FunDef};
use op::{OpCode, CompOp};
use lexer::Token;

grammar;

extern {
    enum Token {
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "->" => Token::RightArrow,
        "-" => Token::Minus,
        "is" => Token::Is,
        "not" => Token::Not,
        "=" => Token::Equals,
        "!=" => Token::Comp(CompOp::Nequals),
        "<"  => Token::Comp(CompOp::Lt),
        "<=" => Token::Comp(CompOp::Lte),
        ">"  => Token::Comp(CompOp::Gt),
        ">=" => Token::Comp(CompOp::Gte),
        "and" => Token::Op(OpCode::And),
        "or" => Token::Op(OpCode::Or),
        "xor" => Token::Op(OpCode::Xor),
        "+" => Token::Op(OpCode::Add),
        "*" => Token::Op(OpCode::Mul),
        "/" => Token::Op(OpCode::Div),
        "^" => Token::Op(OpCode::Pow),
        "." => Token::Dot,
        "," => Token::Comma,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "|" => Token::Alternate,
        "fn" => Token::Fn,
        "none" => Token::None,
        boolean => Token::Bool(<bool>),
        num => Token::Num(<Ratio<i32>>),
        string => Token::Str(<String>),
        identifier => Token::Id(<String>),
    }
}

// a separated list with custom separator and optional trailing end separator
sep_list<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// like sep_list, but needs atleast 1 item and doesn't allow trailing separator
sep_list_plus<T, S>: Vec<T> = {
    <v:(<T> S)*> <e: T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

// comma separated list of values with optional trailing comma
comma<T>: Vec<T> = sep_list<T, ",">;

// expression tier, used for operator precedence
tier<Op, NextTier>: Expr = {
    <lhs: tier<Op, NextTier>> <op: Op> <rhs: NextTier> => Expr::Op(
        FunCall::new_with_args(op, vec![], vec![lhs, rhs])
    ),
    NextTier
};

pub expr: Expr = {
    tier_1_op => <>,
    statement => <>,

    "is" <e: comp_expr> => e,
};

statement: Expr = {
    <id: identifier> "is" <e: tier_1_op> => Expr::Decl(id, Box::new(e)),
    <lhs: identifier> "=" <e: expr> => Expr::Assign(lhs, Box::new(e)),
};

// precedence levels
tier_1_op: Expr = tier<operator_1, tier_2_op>;
tier_2_op: Expr = tier<operator_2, tier_3_op>;
tier_3_op: Expr = tier<operator_3, tier_4_op>;
tier_4_op: Expr = tier<operator_4, tier_5_op>;

tier_5_op: Expr = {
    "-" <e: value> => Expr::Op(
        FunCall::new_with_args(OpCode::Neg, vec![], vec![e])
    ),
    "not" <e: value> => Expr::Op(
        FunCall::new_with_args(OpCode::Not, vec![], vec![e])
    ),
    value => <>,
};

map_pair: (Expr, Expr) = {
    <a: expr> ":" <b: expr> => (a, b),
};

alt_item: (Expr, Expr) = {
    //<map_pair> => <>,
    <expr> => (<>, Expr::Val(1.0f32.into())),
};

value: Expr = {
    term => Expr::Val(<>),
    identifier => Expr::Id(<>),

    "[" <comma<expr>> "]" => Expr::List(<>),
    //"{" <comma<expr>> "}" => Expr::Set(<>.into_iter().collect()),
    "{" <comma<map_pair>> "}" => Expr::Map(<>.into_iter().collect()),

    // alternation that builds a distribution
    "{" <list: sep_list_plus<alt_item, "|">> "}" =>
        Expr::Distribution(list.into_iter().collect()),

    "fn" "{" <args: comma<identifier>> "->" <body: expr> "}" =>
        Expr::Val(Value::Func(FunDef {
            arg_names: args,
            body: Box::new(body),
        })),
    <id: identifier> "(" <args: comma<expr>> ")" => Expr::Op(
        FunCall::new_with_args(OpCode::Id(id), vec![], args)
    ),
    "(" <expr> ")" => <>,
};

term: Value = {
    "none" => Value::None,
    boolean => Value::Bool(<>),
    num => Value::Num(<>),
    string => Value::new_string(&<>),
};

comp_operator: CompOp = {
    "=" => CompOp::Equals,
    "!=" => CompOp::Nequals,
    "<" => CompOp::Lt,
    "<=" => CompOp::Lte,
    ">" => CompOp::Gt,
    ">=" => CompOp::Gte,
};

operator_1: OpCode = {
    "and" => OpCode::And,
    "or" => OpCode::Or,
    "xor" => OpCode::Xor,
};

operator_2: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

operator_3: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

operator_4: OpCode = {
    "^" => OpCode::Pow,
};

comp_expr: Expr =
    <lhs: tier_1_op> <op: comp_operator> <rhs: tier_1_op> =>
        Expr::Comp {
            op: op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        };
