use num::rational::Ratio;

use ast::*;
use value::{Value, FunDef};
use op::{OpCode, CompOp};
use lexer::Token;

grammar;

extern {
    enum Token {
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "->" => Token::RightArrow,
        "-" => Token::Minus,
        "is" => Token::Is,
        "not" => Token::Not,
        "=" => Token::Equals,
        "!=" => Token::Comp(CompOp::Nequals),
        "<"  => Token::Comp(CompOp::Lt),
        "<=" => Token::Comp(CompOp::Lte),
        ">"  => Token::Comp(CompOp::Gt),
        ">=" => Token::Comp(CompOp::Gte),
        "and" => Token::Op(OpCode::And),
        "or" => Token::Op(OpCode::Or),
        "xor" => Token::Op(OpCode::Xor),
        "+" => Token::Op(OpCode::Add),
        "*" => Token::Op(OpCode::Mul),
        "/" => Token::Op(OpCode::Div),
        "^" => Token::Op(OpCode::Pow),
        "." => Token::Dot,
        "," => Token::Comma,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "|" => Token::Alternate,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "global" => Token::Global,
        "local" => Token::Local,
        "var" => Token::Var,
        "none" => Token::None,
        boolean => Token::Bool(<bool>),
        num => Token::Num(<Ratio<i32>>),
        string => Token::Str(<String>),
        identifier => Token::Id(<String>),
        END => Token::End
    }
}

// a separated list with custom separator and optional trailing end separator
sep_list<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// like sep_list, but needs at least 1 item with optional trailing separator
sep_list_plus<T, S>: Vec<T> = {
    <v:(<T> S)+> <e: T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// comma separated list of values with optional trailing comma
comma<T>: Vec<T> = sep_list<T, ",">;

// comma separated list of values with optional trailing comma and at least 1
// item
comma_plus<T>: Vec<T> = sep_list_plus<T, ",">;

// expression tier, used for operator precedence
tier<Op, NextTier>: Expr = {
    <lhs: tier<Op, NextTier>> <op: Op> <rhs: NextTier> => Expr::Op(
        FunCall::new(op, vec![lhs, rhs], vec![])
    ),
    NextTier
};

comp_expr: Expr =
    <lhs: tier_1_op> <op: comp_operator> <rhs: tier_1_op> =>
        Expr::Comp {
            op: op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        };

// without END lalrpop ignores rest of the input if we found a rule match
pub line: Expr = {
    <expr> END => <>,
};

expr: Expr = {
    expr0 => <>,
    // if structure
    "if" <cond: comp_expr> "then" <then_part: expr> "else" <else_part: expr> =>
        Expr::Ctrl(Control::new_if(cond, then_part, else_part)),
};

expr0: Expr = {
    "is" <cmp: comp_expr> => cmp,
    stmt => <>,
    tier_1_op => <>,
};

stmt: Expr = {
    // assignment
    <lhs: lvalue> "=" <rhs: expr> => Expr::Assign(lhs, Box::new(rhs)),
};

lvalue: LValue = {
    <vis: lvalue_visibility?> <root: identifier> <trail: ("." <value>)*> =>
        LValue::new(vis, root, trail),
};

lvalue_visibility: LValVis = {
    "global" => LValVis::Global,
    "local" => LValVis::Local,
    "var" => LValVis::Local,
};

// precedence levels
tier_1_op: Expr = tier<operator_1, tier_2_op>;
tier_2_op: Expr = tier<operator_2, tier_3_op>;
tier_3_op: Expr = tier<operator_3, tier_4_op>;
tier_4_op: Expr = tier<operator_4, tier_5_op>;

tier_5_op: Expr = {
    "-" <e: tier_6_op> => Expr::Op(
        FunCall::new(OpCode::Neg, vec![e], vec![])
    ),
    "not" <e: tier_6_op> => Expr::Op(
        FunCall::new(OpCode::Not, vec![e], vec![])
    ),
    tier_6_op => <>,
};

tier_6_op: Expr = {
    <e: tier_6_op> "(" <args: comma<expr>> ")" => Expr::Op(
        FunCall::new(OpCode::Expr(Box::new(e)), args, vec![])
    ),
    value => <>,
};

map_pair: (Expr, Expr) = {
    <a: expr> ":" <b: expr> => (a, b),
};

alt_item: (Expr, Expr) = {
    <map_pair> => <>,
    <expr> => (<>, Expr::Val(1.0f32.into())),
};

value: Expr = {
    term => Expr::Val(<>),
    identifier => Expr::Id(<>),
    "[" <comma<expr>> "]" => Expr::List(<>),
    "{" <comma<expr>> "}" => Expr::Set(<>.into_iter().collect()),
    "{" ":" ","? "}" => Expr::Map(vec![].into_iter().collect()), // empty map
    "{" <comma_plus<map_pair>> "}" => Expr::Map(<>.into_iter().collect()),
    "{" "|" ","? "}" => Expr::Distribution(vec![].into_iter().collect()),
    "{" <a: alt_item> "|" <list: sep_list<alt_item, "|">> "}" => {
        let mut v = list;
        v.push(a);
        Expr::Distribution(v.into_iter().collect())
    },
    "{" <args: identifier*> "->" <body: expr> "}" =>
        Expr::Val(Value::Func(FunDef {
            arg_names: args,
            body: Box::new(body),
        })),
    "(" <expr> ")" => <>,
};

term: Value = {
    "none" => Value::None,
    boolean => Value::Bool(<>),
    num => Value::Num(<>),
    string => Value::new_string(&<>),
};

comp_operator: CompOp = {
    "=" => CompOp::Equals,
    "!=" => CompOp::Nequals,
    "<" => CompOp::Lt,
    "<=" => CompOp::Lte,
    ">" => CompOp::Gt,
    ">=" => CompOp::Gte,
};

operator_1: OpCode = {
    "and" => OpCode::And,
    "or" => OpCode::Or,
    "xor" => OpCode::Xor,
};

operator_2: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

operator_3: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

operator_4: OpCode = {
    "^" => OpCode::Pow,
};

