use std::str::FromStr;

use num::rational::Ratio;
use num::traits::FromPrimitive;

use ast::*;

grammar;

// comma separated list of values with optional trailing comma
comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// expression tier, used for operator precedence
tier<Op, NextTier>: Expr = {
    <lhs: tier<Op, NextTier>> <op: Op> <rhs: NextTier> => Expr::Op(
        FunCall::new_with_args(op, vec![lhs, rhs])
    ),
    NextTier
};

// a pair separated by a colon
colon_pair<T, U>: (T, U) = <T> ":" <U> => (<>, <>);

pub expr: Expr = {
    infix_op_1 => <>,
    <lhs: infix_op_1> "|" <rhs: infix_op_1> <list: ("|" <infix_op_1>)*> => {
        // alternating chain operation. this is a bit special since it has no 
        // left or right precedence
        let mut vector = vec![lhs, rhs];
        vector.extend(list);
        Expr::Op(FunCall::new_with_args(OpCode::Alternate, vector))
    },
};

// precedence levels
infix_op_1: Expr = tier<operator_1, infix_op_2>;
infix_op_2: Expr = tier<operator_2, infix_op_3>;
infix_op_3: Expr = tier<operator_3, infix_op_4>;
infix_op_4: Expr = tier<operator_4, value>;

value: Expr = {
    term => Expr::Val(<>),
    identifier => Expr::Id(<>),
    "List" "(" <comma<expr>> ")" => Expr::List(<>),
    "Set" "(" <comma<expr>> ")" => Expr::Set(<>.into_iter().collect()),
    <id: identifier> "(" <args: comma<expr>> ")" => Expr::Op(
        FunCall::new_with_args(OpCode::Id(id), args)
    ),
    "(" <expr> ")" => <>,
};

term: Value = {
    "none" => Value::None,
    "true" => Value::Bool(true),
    "false" => Value::Bool(false),
    int => Value::Int(<>),
    float => Value::Real(Ratio::from_f64(<>).unwrap()),
};

identifier: String = r"([\pL_][\pL\pN_]*)" => <>.to_owned();

int: i64 = {
    r"-?[0-9]+" => i64::from_str(<>).unwrap(),
};

float: f64 = {
    // the reason this looks so scary is that we don't want to match integer 
    // literals because that is an ambiguity and lalrpop match structure isn't 
    // working.
    // TODO fix
    r"-?[0-9]+(\.[0-9]+|(\.[0-9]+)?[Ee][-+]?[0-9]+)" =>
    f64::from_str(<>).unwrap(),

};

operator_1: OpCode = {
    "=" => OpCode::Assign,
};

operator_2: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

operator_3: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

operator_4: OpCode = {
    "^" => OpCode::Exp,
};
