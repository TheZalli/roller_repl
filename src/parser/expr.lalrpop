use num::rational::Ratio;

use ast::*;
use value::Value;
use op::OpCode;
use lexer::Token;

grammar;

extern {
    enum Token {
        "(" => Token::LParen,
        ")" => Token::RParen,
        "," => Token::Comma,
        ":" => Token::Colon,
        "|" => Token::Alternate,
        "-" => Token::Minus,
        "+" => Token::Op(OpCode::Add),
        "*" => Token::Op(OpCode::Mul),
        "/" => Token::Op(OpCode::Div),
        "^" => Token::Op(OpCode::Pow),
        "=" => Token::Op(OpCode::Assign),
        "." => Token::Op(OpCode::Dot),
        "none" => Token::None,
        boolean => Token::Bool(<bool>),
        num => Token::Num(<Ratio<i64>>),
        string => Token::Str(<String>),
        identifier => Token::Id(<String>),
    }
}

// comma separated list of values with optional trailing comma
comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// expression tier, used for operator precedence
tier<Op, NextTier>: Expr = {
    <lhs: tier<Op, NextTier>> <op: Op> <rhs: NextTier> => Expr::Op(
        FunCall::new_with_args(op, vec![], vec![lhs, rhs])
    ),
    NextTier
};

// a pair separated by a colon
colon_pair<T, U>: (T, U) = <T> ":" <U> => (<>, <>);

alt_pair: (Expr, Option<Expr>) = {
    <a:infix_op_1> => (a, None),
    <a:infix_op_1> ":" <b:infix_op_1> => (a, Some(b)),
};

pub expr: Expr = {
    infix_op_1 => <>,
    <lhs: alt_pair> "|" <rhs: alt_pair> <list: ("|" <alt_pair>)*> => {
        // alternation that builds a distribution
        use std::collections::BTreeMap;
        let mut distr = BTreeMap::new();

        let one_expr = Expr::Val(1.0f64.into());

        // add left and right sides
        distr.insert(lhs.0, lhs.1.unwrap_or(one_expr.clone()));
        distr.insert(rhs.0, rhs.1.unwrap_or(one_expr.clone()));

        // add the rest
        for (exp, opt_weight) in list {
            distr.insert(exp, opt_weight.unwrap_or(one_expr.clone()));
        }

        // return distribution
        Expr::Distribution(distr)
    },
};

// precedence levels
infix_op_1: Expr = tier<operator_1, infix_op_2>;
infix_op_2: Expr = tier<operator_2, infix_op_3>;
infix_op_3: Expr = tier<operator_3, infix_op_4>;
infix_op_4: Expr = tier<operator_4, value>;

value: Expr = {
    term => Expr::Val(<>),
    identifier => Expr::Id(<>),
    //"List" "(" <comma<expr>> ")" => Expr::List(<>),
    //"Set" "(" <comma<expr>> ")" => Expr::Set(<>.into_iter().collect()),
    <id: identifier> "(" <args: comma<expr>> ")" => Expr::Op(
        FunCall::new_with_args(OpCode::Id(id), vec![], args)
    ),
    "(" <expr> ")" => <>,
};

term: Value = {
    "none" => Value::None,
    boolean => Value::Bool(<>),
    num => Value::Num(<>),
};

operator_1: OpCode = {
    "=" => OpCode::Assign,
};

operator_2: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

operator_3: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

operator_4: OpCode = {
    "^" => OpCode::Pow,
};
